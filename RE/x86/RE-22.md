---
id: RE-22
aliases:
  - re-22
tags:
  - re
  - x86
---

[[RE-TOC]]

# ASM program 1 - Moving immediate data

As said before, we're going to make 32 bits programs, as they are most common among malware.

We're now gonna focus on the AT&T syntax.

Every Assembly program is composed of 3 different sections:

1. **Data section**: Used for declaring initialized data or constants. This data does not change at runtime.
2. **BSS section**: Used for declaring uninitialized data or variables.
3. **Text section**: Section with the actual code. It starts with a global `_start`, which is the application's entry point.

The AT&T syntax uses `#` for comments.

The structure of a statement in AT&T Assembly looks like this:

```asm
[label] mnemonic [operands] [comment]
```

A basic instruction has 2 parts. The first one is the name of the instruction (the mnemonic), the 2nd part is the operands (or parameters of the command).

The following program will demonstrate how to move immediate data to a register and immediate data to memory:

```asm
# moving_immediate_data: mov immediate data between register & memory

.section .data


.section .bss
  .lcomm buffer 1

.section .text
  .globl _start

_start:
  nop # debugging purposes

mov_immediate_data_to_register:
  movl $100, %eax
  movl $0x50, buffer

exit:
  movl $1, %eax
  movl $0, %ebx
  int $0x80
```

To compile this program, we use the command:

```bash
as -32 -o moving_immediate_data.o moving_immediate_data.s
ld -m elf_i386 -o moving_immediate_data moving_immediate_data.o
```

Let's also go over the Intel syntax:

```asm
;moving_immediate_data: mov immediate data between registers & memory

section .data

section .bss
  buffer resb 1

section .text
  global _start

_start:
  nop

mov_immediate_data_to_register:
  mov eax, 100 ;mov 100 into eax
  mov byte[buffer], 0x50 ;mov 0x50 into the buffer memory location

exit:
  mov eax, 1
  mov ebx, 0
  int 0x80
```

To compile this, we run the commands:

```bash
nasm -f elf32 moving_immediate_data.asm
ld -m elf_i386 -o moving_immediate_data moving_immediate_data.o
```

In both cases, we run the program by typing:

```bash
./moving_immediate_data
```

This program doesn't produce an output, which is normal as we're only moving data between registers.

Let's discuss the exit sections of both syntaxes:

```asm
exit:
  movl $1, %eax
  movl $0, %ebx
  int $0x80
```

Here, we take advantage of something known as a software interrupt.

The `movl $1, %eax` line moves the decimal value of 1 into the EAX registry. This specifies the sys_exit call, which will properly terminate the program execution without any segfaults.

`movl $0, %ebx` moves 0 into EBX, giving a successful return value.

Lines 19 and 20 set up the software interrupt, called on line 21. Let's dive into this a bit deeper.

Linux has 2 different distinct areas of memory. At the very bottom of memory in any program execution, we have the Kernel space, made of the dispatcher section and the vector table.

At the very top, we have the user space, made of the stack, the heap, and our code.

![[ASM_1.png]]